The design of this project can be segmented into two mutually exclusive and collectively exhaustive segments: 

1. Frontend (ReactJS, HTML, CSS)
2. Backend (Solidity, Ethereum, Blockchain Smart Contracts)

The choice of ReactJS as the frontend Javascript web framework was due to my prior familiarity with it compared to alternatives (AngularJS, VueJS, etc) and its increased ease and functionality over pure HTML/CSS web design. ReactJS allows for the easy and simple development of dynamic, scalable, and component-based web applications. Additionally, logic written with NodeJS is easily intertwined with HTML elements (defined with JSX), allowing for web app logic to be defined easier. The general architecture of the project is defined in the <code>components</code> directory, which contains every React component used in this web app. The main components are the navbar, main container, the file selection card, and the cards displaying information for each file in a chronological manner. Most of the frontend logic of the web app is defined in <code>App.js</code> and <code>Main.js</code>. In <code>App.js</code>, the interaction with the Web 3.0 smart contracts backend is facilitated by the NPM (NodeJS Package Manager) library <code>Web3.js</code>, which fetches the Ethereum network and account of the current user with the async functions. The functions that are called after a user requests to upload a file (<code>captureFile</code> and <code>uploadFile</code>) are defined in <code>App.js</code>, as well. They are passed as React props to <code>Main.js</code> for execution. Finally, the general layout of the web app is defined in this file, which follows ReactJS naming convention. <code>Navbar.js</code> contains the JSX for rendering the navbar above the main container area in the application. <code>Main.js</code> contains the styling, JSX DOM rendering, and logic information for the card responsible for letting the user upload files. The functions defined in <code>App.js</code> are passed as props to this file and called when the appropriate buttons are clicked. <code>FileView.js</code> is a very simple file that just gets the list of files passed as props and displays all as individual <code>File</code> components mapped with Javascript's <code>map</code> function. <code>File.js</code> defines how individual file components should be rendered with styling information. Finally, <code>index.js</code> is the root of the React application, and compiles the <code>App</code> component (which contains everything the front-end displays) for the DOM to render.

The actual file is stored with a hashed address on an IPFS url using the imported IPFS library in React. Despite the bits of the files themselves not being stored in the blockchain, IPFS is blockchain-secured so the application remains decentralized. The URLs where the files are stored are not available to the public, and consist of hashed values from the original file names and upload dates, so the entire system is secure from a cryptographic perspective. 

Now, let's consider the back end of this application, which is heavily reliant on blockchain and smart contract technology. All the logic for the backend is defind in the <code>contracts</code> directory, and is written in the Solidity progrmaming language (which is specifically used for blockchain/smart contracts applications). <code>Migrations.sol</code> contains the code for modifying the compiled smart contracts in the <code>abis</code> directory. The logic for the web app is stored in <code>DStorage.sol</code>. In this file, we first have global variables defined that are integral to the functionality of the entire application (mappings of files, numbers of files, structs defining file types and file-uploaded events, etc). The constructor defines the uploadFile function, which is the only function in which the smart contracts are required to write information to the Ethereum blockchain. There are several requirements that must be passed for a successful transaction, including the file hash having to exist, the type type having to exist, and the uploader address exists. All smart contracts have the attribute <code>msg.sender</code>, which is the address of the user performing the blockchain transaction. If all the requirements are met (or in other words, the transaction is valid), the <code>fileCount</code> and <code>files</code> variables are updated with the number of files and the files themselves. Finally, an event object is triggered when the file is successfully added to the blockchain. Because the data stored in the smart contract is cryptographically secured with a peer-to-peer network of computers with the Ethereum blockchain, and the IPFS storage itself is blockchain-secured, this file storage system is immutable and distributed, making it more secure than traditional file storage systems. 

One important note is that, when deployed, this project is not actually interacting with a real blockchain. This is because making transactions and adding blocks to a blockchain requires a "gas cost"--a certain amount of Ether (the currency used to power Ethereum). To avoid this real-world cost in ETH, I use the Truffle/Ganache development environment with "fake" cryptocurrency. We can see this gas cost taking place in the video every time I upload a file, as ETH is taken out of my Metamask crypto wallet to power the cryptographical computational power of adding a block to the blockchain.